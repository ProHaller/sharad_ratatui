// Import the necessary modules and structs from other parts of the application or crates.
use crate::{ai::GameAI, audio::AudioNarration, character::CharacterSheet, game_state::GameState};

use async_openai::types::{RunObject, Voice};
use serde::{Deserialize, Serialize};
use std::{
    collections::hash_map::DefaultHasher,
    hash::{Hash, Hasher},
    path::PathBuf,
};

// Define an enumeration to categorize message types within the game.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum MessageType {
    User,   // Message generated by the user.
    Game,   // Message related to game mechanics or progress.
    System, // System-level messages, like errors or notifications.
}

// Structure for user-generated messages containing instructions and actions.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserMessage {
    pub instructions: String,  // Instructions to the player or game master.
    pub player_action: String, // Specific action taken by the player.
}

#[derive(Clone, Serialize, Deserialize)]
pub struct UserCompletionRequest {
    pub language: String,
    pub message: UserMessage,
    pub state: GameState,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Speaker {
    pub index: usize,
    pub name: String,
    pub gender: Gender,
    pub voice: Option<Voice>,
}

#[derive(Serialize, Deserialize, Debug, Hash, Clone)]
pub enum Gender {
    Female,
    Male,
    NonBinary,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FluffLine {
    pub speaker_index: usize,
    pub text: String,
    pub audio: Option<PathBuf>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Fluff {
    pub speakers: Vec<Speaker>,
    pub dialogue: Vec<FluffLine>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct GameMessage {
    pub crunch: String,
    pub fluff: Fluff,
    pub character_sheet: Option<CharacterSheet>,
}

// General structure for all messages used in the system.
#[derive(Clone, Serialize, Deserialize)]
pub struct Message {
    pub message_type: MessageType, // The type of the message (user, game, system).
    pub content: String,           // The content of the message.
}

impl Fluff {
    pub fn render(&self) -> String {
        let mut rendered_fluff = String::new();
        for dialogue in self.dialogue.iter() {
            if let Some(speaker) = self
                .speakers
                .iter()
                .find(|s| s.index == dialogue.speaker_index)
            {
                rendered_fluff.push_str(&format!(
                    "{} {}\n",
                    (if &speaker.name != "Narrator" {
                        format!("\n{}: ", speaker.name)
                    } else {
                        "\n".to_string()
                    }),
                    dialogue.text,
                ));
            }
        }
        rendered_fluff.to_string()
    }
}

impl Speaker {
    pub fn assign_voice(&mut self) {
        let gender_name_tuple = (self.gender.clone(), self.name.clone());

        // Create a hasher and hash the tuple
        let mut hasher = DefaultHasher::new();
        gender_name_tuple.hash(&mut hasher);
        let hash = hasher.finish();

        match self.gender {
            Gender::NonBinary => {
                self.voice = Some(if hash % 2 == 0 {
                    Voice::Alloy
                } else {
                    Voice::Fable
                });
            }
            Gender::Female => {
                self.voice = Some(if hash % 2 == 0 {
                    Voice::Shimmer
                } else {
                    Voice::Nova
                });
            }
            Gender::Male => {
                self.voice = Some(if hash % 2 == 0 {
                    Voice::Onyx
                } else {
                    Voice::Echo
                });
            }
        }
    }
}

// Custom implementation of the Debug trait for the Message struct.
impl std::fmt::Debug for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Custom format to include important fields.
        f.debug_struct("Message")
            .field("message_type", &self.message_type)
            .field("content", &self.content)
            .finish()
    }
}

// Enumeration for AI-generated messages with different purposes.
pub enum AIMessage {
    Game((Vec<Message>, GameAI, GameState)),
    Response(GameMessage),
    NewMessage,
    Load(PathBuf),
    Image(PathBuf),
    AudioNarration(AudioNarration),
}

// Implementation of Message struct, providing a method to create new messages.
impl Message {
    // Constructor for creating a new Message instance.
    pub fn new(message_type: MessageType, content: String) -> Self {
        Message {
            message_type,
            content,
        }
    }
}

// Define a structure for system-generated messages.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SystemMessage {
    pub message: String, // Content of the system message.
}

// Implementation block for UserMessage with a constructor method.
impl UserMessage {
    // Constructor for creating a new UserMessage instance.
    pub fn new(instructions: String, player_action: String) -> Self {
        UserMessage {
            instructions,
            player_action,
        }
    }
}

// Function to create a new UserMessage with predefined instructions.
pub fn create_user_message(language: &str, player_action: &str) -> UserMessage {
    UserMessage::new(
        // Long string for default instructions to act as a professional Game Master.
        format!("Act as the Game Master in a Shadowrun table top role-playing game. Allow the player to attempt one action at a time without providing choices. For actions involving multiple steps or failure points, require the player to choose a course of action at each step. Make sure the story keeps progressing by leading the story line. Keep the story going as a good Game Master, never let the tension fall down. Write your response in valid JSON. Use the following language in the 'fluff': {}.", language).to_string(),
        player_action.to_string(), // Convert the input action to a String and pass it to the new UserMessage.
    )
}
