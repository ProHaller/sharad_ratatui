// Import the necessary modules and structs from other parts of the application or crates.
use crate::character::CharacterSheet;
use async_openai::types::Voice;
use serde::{Deserialize, Serialize};
use std::{
    collections::hash_map::DefaultHasher,
    hash::{Hash, Hasher},
    path::PathBuf,
};

// Define an enumeration to categorize message types within the game.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum MessageType {
    User,   // Message generated by the user.
    Game,   // Message related to game mechanics or progress.
    System, // System-level messages, like errors or notifications.
}

// Structure for user-generated messages containing instructions and actions.
#[derive(Clone, Serialize, Deserialize)]
pub struct UserMessage {
    pub instructions: String,  // Instructions to the game or other users.
    pub player_action: String, // Specific actions taken by the player.
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Speaker {
    pub index: usize,
    pub name: String,
    pub gender: Gender,
    pub voice: Option<Voice>,
}

#[derive(Serialize, Deserialize, Debug, Hash, Clone)]
pub enum Gender {
    Female,
    Male,
    NonBinary,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FluffLine {
    pub speaker_index: usize,
    pub text: String,
    pub audio: Option<PathBuf>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Fluff {
    pub speakers: Vec<Speaker>,
    pub dialogue: Vec<FluffLine>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct GameMessage {
    pub crunch: String,
    pub fluff: Fluff,
    pub character_sheet: Option<CharacterSheet>,
}

// General structure for all messages used in the system.
#[derive(Clone, Serialize, Deserialize)]
pub struct Message {
    pub message_type: MessageType, // The type of the message (user, game, system).
    pub content: String,           // The content of the message.
}

impl Fluff {
    pub fn render(&self) -> String {
        let mut rendered_fluff = String::new();
        for dialogue in self.dialogue.iter() {
            if let Some(speaker) = self
                .speakers
                .iter()
                .find(|s| s.index == dialogue.speaker_index)
            {
                rendered_fluff.push_str(&format!(
                    "{} {}\n",
                    (if &speaker.name != "Narrator" {
                        format!("\n{}: ", speaker.name)
                    } else {
                        "\n".to_string()
                    }),
                    dialogue.text,
                ));
            }
        }
        rendered_fluff.to_string()
    }
}

impl Speaker {
    pub fn assign_voice(&mut self) {
        let gender_name_tuple = (self.gender.clone(), self.name.clone());

        // Create a hasher and hash the tuple
        let mut hasher = DefaultHasher::new();
        gender_name_tuple.hash(&mut hasher);
        let hash = hasher.finish();

        match self.gender {
            Gender::NonBinary => {
                self.voice = Some(if hash % 2 == 0 {
                    Voice::Alloy
                } else {
                    Voice::Fable
                });
            }
            Gender::Female => {
                self.voice = Some(if hash % 2 == 0 {
                    Voice::Shimmer
                } else {
                    Voice::Nova
                });
            }
            Gender::Male => {
                self.voice = Some(if hash % 2 == 0 {
                    Voice::Onyx
                } else {
                    Voice::Echo
                });
            }
        }
    }
}

// Custom implementation of the Debug trait for the Message struct.
impl std::fmt::Debug for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Custom format to include important fields.
        f.debug_struct("Message")
            .field("message_type", &self.message_type)
            .field("content", &self.content)
            .finish()
    }
}

// Enumeration for AI-generated messages with different purposes.
pub enum AIMessage {
    Debug(String),
}

// Implementation of Message struct, providing a method to create new messages.
impl Message {
    // Constructor for creating a new Message instance.
    pub fn new(message_type: MessageType, content: String) -> Self {
        Message {
            message_type,
            content,
        }
    }
}
