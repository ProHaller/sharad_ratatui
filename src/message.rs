use std::path::PathBuf;

// Import the necessary modules and structs from other parts of the application or crates.
use crate::character::CharacterSheet;
use crate::error::AppError;
use async_openai::types::Voice;
use serde::{Deserialize, Serialize};

// Define an enumeration to categorize message types within the game.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum MessageType {
    User,   // Message generated by the user.
    Game,   // Message related to game mechanics or progress.
    System, // System-level messages, like errors or notifications.
}

// Structure for user-generated messages containing instructions and actions.
#[derive(Clone, Serialize, Deserialize)]
pub struct UserMessage {
    pub instructions: String,  // Instructions to the game or other users.
    pub player_action: String, // Specific actions taken by the player.
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Speaker {
    index: usize,
    name: String,
    gender: Gender,
    voice: Option<Voice>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
enum Gender {
    NonBinary,
    Female,
    Male,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct FluffLine {
    speaker_index: usize,
    text: String,
    audio: Option<PathBuf>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Fluff {
    speakers: Vec<Speaker>,
    dialogue: Vec<FluffLine>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct GameMessage {
    pub crunch: String,
    pub fluff: Fluff,
    pub character_sheet: Option<CharacterSheet>,
}

impl GameMessage {
    pub fn new(crunch: String, fluff: Fluff, character_sheet: Option<CharacterSheet>) -> Self {
        GameMessage {
            crunch,
            fluff,
            character_sheet,
        }
    }
}

// General structure for all messages used in the system.
#[derive(Clone, Serialize, Deserialize)]
pub struct Message {
    pub message_type: MessageType, // The type of the message (user, game, system).
    pub content: String,           // The content of the message.
}

impl Fluff {
    pub fn render(&self) -> String {
        let mut rendered_fluff = String::new();
        for dialogue in self.dialogue.iter() {
            if let Some(speaker) = self
                .speakers
                .iter()
                .find(|s| s.index == dialogue.speaker_index)
            {
                rendered_fluff.push_str(&format!(
                    "{} {}\n",
                    (if &speaker.name != "Narrator" {
                        format!("{}:\t", speaker.name)
                    } else {
                        "\n".to_string()
                    }),
                    dialogue.text,
                ));
            }
        }
        rendered_fluff.to_string()
    }
}
// Custom implementation of the Debug trait for the Message struct.
impl std::fmt::Debug for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Custom format to include important fields.
        f.debug_struct("Message")
            .field("message_type", &self.message_type)
            .field("content", &self.content)
            .finish()
    }
}

// Enumeration for AI-generated messages with different purposes.
pub enum AIMessage {
    Debug(String),
    Response(Result<GameMessage, AppError>),
}

// Implementation of Message struct, providing a method to create new messages.
impl Message {
    // Constructor for creating a new Message instance.
    pub fn new(message_type: MessageType, content: String) -> Self {
        Message {
            message_type,
            content,
        }
    }
}
